#include "mfem.hpp"
#include <fstream>
#include <iostream>

using namespace std;
using namespace mfem;

/*****************************************\
! Nonlinear functions
!
! A non-linear function that is used to
! generate the evaluations in the non-linear
! grid-function-coefficient
!
\*****************************************/
static const double alpha = -0.5;
double  f(const double & u, const Vector & x){ return exp(alpha*u); }
double df(const double & u, const Vector & x){ return alpha*exp(alpha*u); }


/*****************************************\
! Nonlinear Grid function Coefficient
!
! A non-linear gridfunction coefficient
! that varies with, space time and 
! Gfunction value.
!
\*****************************************/
class NonlinearGridFuncCoefficient : public Coefficient
{
   GridFunction &gf;
   function<double(const double &, const Vector &)>          GFunction;
   function<double(const double &, const Vector &, double)>  TDGFunction;
public:
   NonlinearGridFuncCoefficient(GridFunction &gf_
                      , function<double(const double &, const Vector &)> foo)
                      : gf(gf_), GFunction( move(foo) ) {};

   NonlinearGridFuncCoefficient(GridFunction & gf_
                      , function<double(const double &, const Vector &, double)> foo)
                      : gf(gf_), TDGFunction( move(foo) ) {};

    double Eval(ElementTransformation &T, const IntegrationPoint &ip)
    {
      double x[3];
      Vector transip(x, 3);
      T.Transform(ip, transip);
      return (GFunction)? GFunction(gf.GetValue(T, ip), transip) 
                        : TDGFunction(gf.GetValue(T, ip), transip, GetTime() );
    }
};

/*****************************************\
! A new non-linear form
!
! Singularly non-linear test problem
! c(u)u  + Laplacian (u) - f = R(u)
! dc(u)M + Laplacian = Jac(u)
\*****************************************/
class SohailsNLForm: public Operator{
  private:
    ParFiniteElementSpace &fes;
    GridFunction x_gf, b_gf;
    Array<int> dofs;

    ParLinearForm   *Residual=NULL; 
    ParBilinearForm *Jacobian=NULL;
    mutable OperatorHandle GradR;
  public:
    SohailsNLForm(NonlinearGridFuncCoefficient cf
                , NonlinearGridFuncCoefficient dcf
	            , ParFiniteElementSpace & fes);

    // Required to use the native newton solver
    virtual void Mult(const Vector &k, Vector &y) const override;   //Residual Vector
    virtual Operator &GetGradient(const Vector &xp) const override; //Jacobian Matrix
};

/*****************************************\
!  Constructs the non-linear
!  form problem class
\*****************************************/
SohailsNLForm::SohailsNLForm(NonlinearGridFuncCoefficient cf
                           , NonlinearGridFuncCoefficient dcf
                           , ParFiniteElementSpace & fes_):
						   fes(fes_), x_gf(&fes), Operator()
{
  //Forms the residual vector
  GradientGridFunctionCoefficient gradCf(x_gf);
  Residual = new ParLinearForm(&fes);
  Residual->AddDomainIntegrator(new DomainLFIntegrator(cf));
  Residual->AddDomainIntegrator(new DomainLFGradIntegrator(gradCf));


  //Forms the Jacobian matrix which is the
  //gradient of the residual
  Jacobian = new ParBilinearForm(&fes);
  Jacobian->AddDomainIntegrator(new MassIntegrator(dcf) );
  Jacobian->AddDomainIntegrator(new DiffusionIntegrator );
}; 


/*****************************************
! R = b - F(x)
! Grad(R)_x = A
!
! f(u) + grad(u).grad(u) = 0 = R(u)
! f'(u) M + grad(u).grad() = J(u)
!
! Constructs/updates the residual form
! which is basically a glorified
! linear form, then updates the Jacobian
! (glorified bilinear form)
\*****************************************/
void SohailsNLForm::Mult(const Vector & x, Vector & r) const{
 //  x_gf.Distribute(&x);
//   Residual->Update();
   Residual->Assemble();
   Residual->ParallelAssemble(r);
   Array<int> empty_tdof_list;  // empty

   Jacobian->FormSystemMatrix(empty_tdof_list, GradR);
};

/*****************************************\
! Passes a handle to the operator
! that is generated by bilinear form
! effectively giving a handle to the
! Jacobian matrix
\*****************************************/
Operator &SohailsNLForm::GetGradient(const Vector &xp) const{
  return *GradR;
};


/*****************************************\
! A main function to test the functionality
! of my newly made non-linear-form class
! and non-linear function of Grid-function
! coefficient
!
\*****************************************/
int main(int argc, char *argv[])
{
   Mpi::Init();
   Hypre::Init();

   // 1. Parse command line options
   const char *mesh_file = "mesh/star.mesh";
   int order = 1;

   OptionsParser args(argc, argv);
   args.AddOption(&mesh_file, "-m", "--mesh", "Mesh file to use.");
   args.AddOption(&order, "-o", "--order", "Finite element polynomial degree");
   args.ParseCheck();

   // 2. Read the mesh from the given mesh file, and refine once uniformly.
   Mesh mesh(mesh_file);
   mesh.UniformRefinement();
   ParMesh pmesh(MPI_COMM_WORLD, mesh);

   // 3. Define a finite element space on the mesh. Here we use H1 continuous
   //    high-order Lagrange finite elements of the given order.
   H1_FECollection fec(order, mesh.Dimension());
   ParFiniteElementSpace fespace(&pmesh, &fec);
   cout << "Number of DOFs: " << fespace.GetTrueVSize() << endl;

   // 4. Extract the list of all the boundaries. These will be marked as
   //    Dirichlet in order to enforce zero boundary conditions.
   Array<int> ess_bdr(pmesh.bdr_attributes.Max());
   ess_bdr = 1;

   // 5. Define the solution x as a finite element grid function in fespace. Set
   //    the initial guess to zero, which also sets the boundary conditions.
   ParGridFunction x(&fespace);
   x = 0.0;

   // 8. Get true dof vectors and set essential BCs on rhs.
   Vector X(fespace.GetTrueVSize()), B(fespace.GetTrueVSize());
   ParGridFunction U_sol(&fespace), B_vec(&fespace);
   NonlinearGridFuncCoefficient coeff(U_sol,f);
   NonlinearGridFuncCoefficient dcoeff(U_sol,df);
   SohailsNLForm sampleProb(coeff, dcoeff, fespace);

   // 9. Set up the Newton solver. Each Newton iteration requires a linear
   //    solve. Here we use Conjugate Gradients to solve the linear system
   CGSolver solver(MPI_COMM_WORLD);
   NewtonSolver newton(MPI_COMM_WORLD);
   newton.SetOperator(sampleProb);
   newton.SetSolver(solver);
   newton.SetPrintLevel(1);
   newton.SetRelTol(1e-10);
   newton.SetMaxIter(20);
/*
   // 10. Solve the nonlinear system.
   B_vec = 0.0;
   newton.Mult(B_vec, U_sol);
   x.Distribute(X);

   // 11. Output for ParaView visualisation.
   {
      ParaViewDataCollection pd("Diffusion", &pmesh);
      pd.SetPrefixPath("ParaView");
      pd.RegisterField("solution", &x);
      pd.SetLevelsOfDetail(order);
      pd.SetDataFormat(VTKFormat::BINARY);
      pd.SetHighOrderOutput(true);
      pd.SetCycle(0);
      pd.SetTime(0.0);
      pd.Save();
   }
*/
   return 0;
}
